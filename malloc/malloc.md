# TP: malloc

En primer lugar, se definieron dos estructuras: `region` y `block`, donde la primera representa una sección contigua de memoria virtual que la biblioteca le devuelve al usuario, y la segunda es utilizada por la biblioteca para administrar la memoria de forma más ordenada. De esta forma, se trabaja con _regiones_ que quedan contenidas en _bloques_. Tanto _bloques_ como _regiones_ se trabajan como listas doblemente enlazadas. Cabe aclarar que para realizar la primera parte del trabajo, donde solo se requería tener un bloque pequeño, se trabajó solo con regiones (particularmente una lista de regiones), y la estructura del bloque se incorporó después cuando ya era necesario tener bloques de distintos tamaños.

También se definieron distintas _macros_ que ayudan a realizar aritmética de punteros de forma más ordenada y permiten el movimiento entre regiones o bloques sin tener que conocer sus tamaños. 

Luego, para poder administrar la memoria de forma más ordenada, se definieron tres listas de bloques, una por cada tamaño permitido: tamaño pequeño (16Kib), tamaño mediano (1Mib) y tamaño grande (32Mib). De esta forma, los bloques de distintos tamaños quedan separados y es más fácil encontrar el bloque adecuado para el tamaño de memoria que el usuario reserva. Por ejemplo, si se quieren reservar más de 1Mib (tamaño mediano) se recorrerá directamente la lista de bloques grandes buscando alguna región libre para devolver. Además, hay una lista que contiene las tres listas ordenadas por tamaño, para facilitar la búsqueda de regiones. La función `list_index` retorna el índice en el que se encuentra la lista del tamaño que se necesita.

Si el usuario quiere reservar una región de memoria de tamaño mayor al bloque grande la biblioteca fallará, y, por el contrario, hay un mínimo de tamaño para las regiones; si el usuario quiere reservar menos memoria se devuelve siempre una región con el tamaño mínimo. 

A la hora de buscar regiones libres para devolverle al usuario se pueden utilizar dos estrategias distintas: **first fit** o **best fit**; cuando se ejecuta el programa el usuario puede seleccionar la estrategia que prefiere. Si se elige **first fit** se recorrerán las listas de bloques de tamaño mayor o igual a la memoria que se quiere reservar (no tendría sentido recorrer la lista de bloques pequeños si se quieren reservar más de 16Kib, por ejemplo) hasta encontrar la primera región libre de tamaño mayor o igual al pedido. Esta estrategia tiene la ventaja de ser más rápida pero puede suceder que la región tenga más memoria de la que necesita el usuario, por lo que habrá que hacer un `split` para evitar la fragmentación interna. Por otro lado, con **best fit** se recorren las listas de bloques de tamaño mayor o igual al pedido por el usuario pero buscando la menor de las regiones con tamaño suficiente. Es un poco más lento ya que, además de recorrer todas las listas hasta el final, debe ir comparando el tamaño de las regiones y guardando la mejor región. 

Cuando se invoca `malloc` para reservar memoria lo primero que se hace es buscar una región libre con `find_free_region` y el tamaño que se necesita (teniendo en cuenta que si es menor que el mínimo se reservará una región con el tamaño mínimo); si `find_free_region` retorna _NULL_ significa que no hay regiones con el tamaño necesario, por lo que se invoca a `grow_heap`. Esta función se encarga de hacer "crecer el heap" creando bloques nuevos, y para eso se utiliza `mmap`. Como se mencionó previamente, si la región tiene un tamaño mayor al que se reservó es necesario hacer un `split`, es decir, dividir a la región en dos regiones para evitar fragmentación interna. Finalmente, se retorna la región de memoria que se reservó o _NULL_ en caso de error. 

Por otra parte, cuando se invoca `free` para liberar memoria previamente reservada primero es necesario asegurar que la región estaba ocupada, para evitar los errores que pueden surgir de un _double free_. Luego, se marca la región como libre y se aplica `coalescing`, esto es unir regiones libres contiguas (puede ser contigua tanto a izquierda como a derecha) para no tener fragmentación externa. Cabe aclarar que luego de realizar `split` también es necesario hacer `coalescing` ya que puede suceder que queden regiones libres contiguas fragmentadas, y si más adelante se busca una región de un tamaño mayor puede que no se la encuentre debido a esto. Es necesario también revisar si la región liberada es la última del bloque, ya que si un bloque queda completamente libre será necesario liberar esa memoria. En caso de que el bloque esté libre, se lo libera utilizando `munmap`.  

La biblioteca también incluye las funciones `calloc` y `realloc`. En el caso de `calloc`, si el tamaño recibido es válido (no genera un _overflow_), se llama a `malloc` y luego se inicializa toda esa región en 0 antes de devolverla. Para `realloc` hay que tener más consideraciones: si el tamaño recibido es mayor al máximo permitido se retorna _NULL_, si el puntero recibido es _NULL_ la llamada a `realloc` funciona como `malloc`, y si el tamaño recibido es 0 la llamada a `realloc` funciona como `free`. Luego, si la región a la que apunta el puntero recibido tiene el tamaño pedido se hace un `split` para evitar fragmentación interna y se devuelve esa región; si la región proxima a la que se quiere agrandar está libre y tiene el tamaño necesario se hace un `coalescing` de ambas regiones y se retorna un puntero a esta nueva región agrandada; finalmente, si ninguno de los otros casos se cumple es necesario llamar a `malloc` y copiar el contenido de la región vieja en la nueva, para después liberar la vieja y devolver la nueva. 
